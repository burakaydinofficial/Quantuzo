[
  {
    "instance_id": "matplotlib__matplotlib-18869",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..e94dbc49a7 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -132,14 +132,20 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n \n def __getattr__(name):\n     if name == \"__version__\":\n+\n+version_info = tuple(map(int, __version__.split(\".\")[:-1]))\n         import setuptools_scm\n         global __version__  # cache it.\n+\n+version_info = tuple(map(int, __version__.split(\".\")[:-1]))\n         # Only shell out to a git subprocess if really needed, and not on a\n         # shallow clone, such as those used by CI, as the latter would trigger\n         # a warning from setuptools_scm.\n         root = Path(__file__).resolve().parents[2]\n         if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n             __version__ = setuptools_scm.get_version(\n+\n+version_info = tuple(map(int, __version__.split(\".\")[:-1]))\n                 root=root,\n                 version_scheme=\"post-release\",\n                 local_scheme=\"node-and-date\",\n@@ -147,7 +153,11 @@ def __getattr__(name):\n             )\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n+\n+version_info = tuple(map(int, __version__.split(\".\")[:-1]))\n         return __version__\n+\n+version_info = tuple(map(int, __version__.split(\".\")[:-1]))\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n@@ -166,9 +176,13 @@ def _check_versions():\n     ]:\n         module = importlib.import_module(modname)\n         if parse_version(module.__version__) < parse_version(minver):\n+\n+version_info = tuple(map(int, __version__.split(\".\")[:-1]))\n             raise ImportError(f\"Matplotlib requires {modname}>={minver}; \"\n                               f\"you have {module.__version__}\")\n \n+version_info = tuple(map(int, __version__.split(\".\")[:-1]))\n+\n \n _check_versions()\n \n@@ -786,9 +800,15 @@ def _rc_params_in_file(fname, transform=lambda x: x, fail_on_error=False):\n                 addendum=\"Please update your matplotlibrc.\")\n         else:\n             # __version__ must be looked up as an attribute to trigger the\n+\n+version_info = tuple(map(int, __version__.split(\".\")[:-1]))\n             # module-level __getattr__.\n             version = ('master' if '.post' in mpl.__version__\n+\n+version_info = tuple(map(int, __version__.split(\".\")[:-1]))\n                        else f'v{mpl.__version__}')\n+\n+version_info = tuple(map(int, __version__.split(\".\")[:-1]))\n             _log.warning(\"\"\"\n Bad key %(key)s in file %(fname)s, line %(line_no)s (%(line)r)\n You probably need to get an updated matplotlibrc file from\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-22711",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex da5b40a5ef..1536432123 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -903,7 +903,7 @@ class RangeSlider(SliderBase):\n             xy[1] = .25, val[1]\n             xy[2] = .75, val[1]\n             xy[3] = .75, val[0]\n-            xy[4] = .25, val[0]\n+            \n         else:\n             xy[0] = val[0], .25\n             xy[1] = val[0], .75\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-22835",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..7d3df97c1a 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1275,6 +1275,12 @@ class Artist:\n         return None\n \n     def format_cursor_data(self, data):\n+        try:\n+            inv_data = self.norm.inverse(data)\n+        except ValueError:\n+            # BoundaryNorm is not invertible; fallback to original data\n+            inv_data = data\n+        return inv_data\n         \"\"\"\n         Return a string representation of *data*.\n \n"
  },
  {
    "instance_id": "matplotlib__matplotlib-23314",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/mpl_toolkits/mplot3d/axes3d.py b/lib/mpl_toolkits/mplot3d/axes3d.py\nindex 9db44b7994..e37f437b62 100644\n--- a/lib/mpl_toolkits/mplot3d/axes3d.py\n+++ b/lib/mpl_toolkits/mplot3d/axes3d.py\n@@ -171,6 +171,9 @@ class Axes3D(Axes):\n \n         # mplot3d currently manages its own spines and needs these turned off\n         # for bounding box calculations\n+    def set_visible(self, visible):\n+\\        super().set_visible(visible)\n+\n         self.spines[:].set_visible(False)\n \n         if auto_add_to_figure:\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-23562",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..cee2c4c411 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -661,6 +661,7 @@ def patch_collection_2d_to_3d(col, zs=0, zdir='z', depthshade=True):\n \n \n class Poly3DCollection(PolyCollection):\n+    _facecolors2d = None\n     \"\"\"\n     A collection of 3D polygons.\n \ndiff --git a/test_poly3d.py b/test_poly3d.py\nnew file mode 100644\nindex 0000000000..1823790068\n--- /dev/null\n+++ b/test_poly3d.py\n@@ -0,0 +1,11 @@\n+import numpy as np\n+import matplotlib.tri as mtri\n+import matplotlib.pyplot as plt\n+from mpl_toolkits.mplot3d import Axes3D\n+\n+y, x = np.ogrid[1:10:100j, 1:10:100j]\n+z2 = np.cos(x)**3 - np.sin(y)**2\n+fig = plt.figure()\n+ax = fig.add_subplot(111, projection='3d')\n+r = ax.plot_surface(x, y, z2, cmap='hot')\n+print(r.get_facecolors())\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-23563",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/test_plot.py b/test_plot.py\nnew file mode 100644\nindex 0000000000..bee55f8cc4\n--- /dev/null\n+++ b/test_plot.py\n@@ -0,0 +1,26 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+# Correctly initialize arrays with numeric values\n+x_s_0 = np.array([1, 2, 3, 4, 5])\n+x_e_0 = np.array([2, 3, 4, 5, 6])\n+y_s_0 = np.array([1, 2, 3, 4, 5])\n+y_e_0 = np.array([2, 3, 4, 5, 6])\n+z_s_0 = np.array([1, 2, 3, 4, 5])\n+z_e_0 = np.array([2, 3, 4, 5, 6])\n+\n+fig = plt.figure()\n+ax = fig.gca(projection='3d')\n+ax.view_init(elev=90, azim=0)\n+ax.set_zlim3d(-10, 10)\n+clr_list = 'r-'\n+\n+for n in range(len(z_s_0)):\n+    ax.plot([x_s_0[n], x_e_0[n]],\n+            [y_s_0[n], y_e_0[n]],\n+            [z_s_0[n], z_e_0[n]], clr_list)\n+\n+plt.xlabel('x')\n+plt.ylabel('y')\n+plt.title('90-0')\n+plt.show()\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-23964",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/matplotlib/backends/backend_ps.py b/lib/matplotlib/backends/backend_ps.py\nindex f209e811f1..6f9f3917dc 100644\n--- a/lib/matplotlib/backends/backend_ps.py\n+++ b/lib/matplotlib/backends/backend_ps.py\n@@ -670,6 +670,7 @@ grestore\n \n         self.set_color(*gc.get_rgb())\n \n+n    if curr_stream:\n         for ps_name, xs_names in stream:\n             self.set_font(ps_name, prop.get_size_in_points(), False)\n             thetext = \"\\n\".join(f\"{x:g} 0 m /{name:s} glyphshow\"\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-23987",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/matplotlib/figure.py.patch b/lib/matplotlib/figure.py.patch\nnew file mode 100644\nindex 0000000000..ffdb7affcf\n--- /dev/null\n+++ b/lib/matplotlib/figure.py.patch\n@@ -0,0 +1,15 @@\n+--- /testbed/lib/matplotlib/figure.py\n++++ /testbed/lib/matplotlib/figure.py\n+@@ -123,6 +123,10 @@\n+             \"incompatible with subplots_adjust and/or tight_layout; \"\n+             \"not calling subplots_adjust.\")\n+         if self.constrained_layout:\n++            return\n++        self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n++        for ax in self.axes:\n++            if hasattr(ax, 'get_subplotspec'):\n++                ax._set_position(ax.get_subplotspec().get_position(self))\n++        self.stale = True\n++\n+     def align_xlabels(self, axs=None):\n+         \"\"\"\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-24265",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/test_style_bug.py b/test_style_bug.py\nnew file mode 100644\nindex 0000000000..c87500d768\n--- /dev/null\n+++ b/test_style_bug.py\n@@ -0,0 +1,15 @@\n+import matplotlib.pyplot as plt\n+\n+# Attempt to access the style\n+try:\n+    the_rc = plt.style.use(\"seaborn-colorblind\")\n+plt.style.library[\"seaborn-colorblind\"]\n+    print(\"Style found successfully.\")\n+except KeyError as e:\n+    print(f\"KeyError: {e}\")\n+    # Try to register the style explicitly\n+    try:\n+        plt.style.use(\"seaborn-colorblind\")\n+        print(\"Style registered successfully.\")\n+    except Exception as e2:\n+        print(f\"Failed to register style: {e2}\")\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-24970",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..e9e50d9f25 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -727,9 +727,9 @@ class Colormap:\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n-        xa[xa > self.N - 1] = self._i_over\n-        xa[xa < 0] = self._i_under\n-        xa[mask_bad] = self._i_bad\n+        xa[xa > self.N - 1] = np.array(self._i_over).astype(np.uint8)\n+        xa[xa < 0] = np.array(self._i_under).astype(np.uint8)\n+        xa[mask_bad] = np.array(self._i_bad).astype(np.uint8)\n \n         lut = self._lut\n         if bytes:\ndiff --git a/test_deprecation.py b/test_deprecation.py\nnew file mode 100644\nindex 0000000000..9e12b2848d\n--- /dev/null\n+++ b/test_deprecation.py\n@@ -0,0 +1,4 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+plt.get_cmap()(np.empty((0,), dtype=np.uint8))\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-25079",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex bf88dd2b68..6a6e14cf49 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -859,6 +859,13 @@ class Collection(artist.Artist, cm.ScalarMappable):\n         return mapped or changed\n \n     def update_scalarmappable(self):\n+        # Validate vmin and vmax for LogNorm\n+        if hasattr(self, \"norm\") and isinstance(self.norm, LogNorm):\n+            if self.norm.vmin <= 0 or self.norm.vmax <= 0:\n+                raise ValueError(\"Invalid vmin or vmax for LogNorm\")\n+            if self.norm.vmin >= self.norm.vmax:\n+                raise ValueError(\"Invalid vmin or vmax for LogNorm\")\n+        super().update_scalarmappable()\n         \"\"\"\n         Update colors from the scalar mappable array, if any.\n \n"
  },
  {
    "instance_id": "matplotlib__matplotlib-25311",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/matplotlib/backends/backend_qtagg.py b/lib/matplotlib/backends/backend_qtagg.py\nindex f64264d712..a79a979903 100644\n--- a/lib/matplotlib/backends/backend_qtagg.py\n+++ b/lib/matplotlib/backends/backend_qtagg.py\n@@ -71,10 +71,23 @@ class FigureCanvasQTAgg(FigureCanvasAgg, FigureCanvasQT):\n         finally:\n             painter.end()\n \n-    def print_figure(self, *args, **kwargs):\n-        super().print_figure(*args, **kwargs)\n-        self.draw()\n+    def __getstate__(self):\n+        \"\"\"Custom pickling for FigureCanvasQTAgg.\"\"\"\n+        state = super().__getstate__()\n+        # Ensure interactive elements like draggable legends are preserved\n+        # during pickling by including their state\n+        # This is a placeholder; actual implementation may require deeper\n+        # integration with matplotlib's figure state management.\n+        return state\n \n+    def __setstate__(self, state):\n+        \"\"\"Restore state after pickling for FigureCanvasQTAgg.\"\"\"\n+        super().__setstate__(state)\n+        # Reinitialize any interactive elements that might have been lost\n+        # during pickling\n+        # This is a placeholder; actual implementation may require deeper\n+        # integration with matplotlib's figure state management.\n+        pass\n \n @_BackendQT.export\n class _BackendQTAgg(_BackendQT):\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-25433",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/test_slider_bug.py b/test_slider_bug.py\nnew file mode 100644\nindex 0000000000..b52e68487b\n--- /dev/null\n+++ b/test_slider_bug.py\n@@ -0,0 +1,28 @@\n+import matplotlib.pyplot as pyplot\n+import matplotlib.widgets as widgets\n+\n+def onchanged(values):\n+    print(\"on changed\")\n+    print(values)\n+    pyplot.clf()\n+    addElements()\n+\n+def onclick(e):\n+    print(\"on click\")\n+    pyplot.clf()\n+    addElements()\n+    \n+\n+def addElements():\n+    ax = pyplot.axes([0.1, 0.45, 0.8, 0.1])\n+    global slider\n+    slider = widgets.RangeSlider(ax, \"Test\", valmin=1, valmax=10, valinit=(1, 10))\n+    slider.on_changed(onchanged)\n+    ax = pyplot.axes([0.1, 0.30, 0.8, 0.1])\n+    global button\n+    button = widgets.Button(ax, \"Test\")\n+    button.on_clicked(onclick)\n+\n+addElements()\n+\n+pyplot.show()\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-25498",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..715650e0c8 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1063,6 +1063,8 @@ class Colorbar:\n             ax.set_subplotspec(subplotspec)\n \n     def _process_values(self):\n+        if self.norm is None or (self.norm.vmin == 0 and self.norm.vmax == 0):\n+            return \n         \"\"\"\n         Set `_boundaries` and `_values` based on the self.boundaries and\n         self.values if not None, or based on the size of the colormap and\n"
  },
  {
    "instance_id": "matplotlib__matplotlib-26011",
    "model_name_or_path": "local/qwen3-4b-instruct-2507",
    "model_patch": "litellm.BadRequestError: OpenAIException - request (65642 tokens) exceeds the available context size (65536 tokens), try increasing it"
  }
]